<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用 fastlane 进行 iOS App自动打包]]></title>
    <url>%2F2018%2F06%2F27%2Fuse-fastlane%2F</url>
    <content type="text"><![CDATA[使用 fastlane 进行 iOS App自动打包前言公司 App工厂 项目每天要进行10来次打包分发测试，并且要根据要求按环境、配置进行打包。如果使用手动的方式，不仅效率低，还容易配置出错，对于开发人员来说相当折磨。 Xcodebuild 是一个命令行打包命令，配合脚本使用可以实现简单的打包分发流程，可是不方便更改项目内的一些配置和灵活管理开发者中心的 Certificates 、 Identifiers 、 Provisioning Profiles 。 Fastlane 不仅可以更快的打包，还能够帮助开发者团队管理证书，生成 App ID 、 Provisioning Profile ，生成应用截图，处理代码签名，甚至提交审核。 接下来记录一下我使用 fastlane 时碰到的一些问题。 使用 fastlane首先安装fastlane1xcode-select --install 1[sudo] gem install fastlane -NV 加载.env文件里的环境变量，使用 dotenv —— A Ruby gem to load environment variables from .env.Add this line to the top of your application’s Gemfile: 1gem &apos;dotenv-rails&apos;, groups: [:development, :test] 1$ bundle 1$ gem install dotenv 使用 update_info_plist error: You must specify either a plist path or a scheme 必须设置 plist path 或者 scheme ，然后就可以找到对应的 plist 文件更改CFBundleDisplayName，CFBundleShortVersionString之类的值了。 注意： 使用 update_info_plist 修改不了项目Bundle ID（一般info.plist文件里面CFBundleIdentifier的值是$(PRODUCT_BUNDLE_IDENTIFIER)），因为并不会修改Build Settings里PRODUCT_BUNDLE_IDENTIFIER的值。参考 issue。 produce error: User foo@bar.com doesn’t have enough permission for the following action: user_details_data 出现这个错误是由于我用的开发者账号（企业账号）没有 user_details_data 的权限（应该是跟 appstoreconnect 相关），而参数 skip_itc 没有设为 false 。 还有一个问题是：要想使用 produce 修改已经生成的App ID的 services ，目前produce cannot modify services with a lane，参考这个issue，可以改用命令行修改， 1sh &quot;fastlane produce enable_services --push_notification -a #&#123;bundle_id&#125;&quot; 去文档上查了一下发现有 modify_services 这个 action 可以修改，不过我没有去使用过。 如果项目里有multiple targets (e.g. Today Widget or WatchOS Extension or Notification Extension)，也需要使用produce创建对应的App ID。然而我碰到过另一个问题： An App ID with Identifier ‘com.foo.bar.push’ is not available. Please enter a different string 这个错误应该是由于com.foo.bar.push这个Bundle ID被其它开发者账号用来创建了App ID，解决办法就是： 改用另一个 去那个开发者账号（如果你知道）删除对应的App ID。 可是Xcode开启了自动签名却能生成有效的pp文件，我检查了一下pp文件，发现App ID名称是XC Wildcard，能匹配所有的Bundle ID。接下来我去查了一下资料，发现这是因为Extension的target不使用capabilities，当Xcode开启自动签名，fix issue时，可能会adding a wildcard team provisioning profile， Using a Wildcard App ID is convenient for all apps that do not use capabilities, as they can reuse the same provisioning profile for code signing match error: Could not create another Distribution certificate, reached the maximum number of available Distribution certificates. 当开发者账户中已经有了最大数量的证书时，fastlane match不能创建新的证书，然而也不能使用本地 keychain 中可用的证书并推送到git仓库。 这个 issue 就有人提到希望fastlane match可以使用本地可用的证书。 There will be good to have build-in initializer to export all existing certificates to git repo. The steps are, for example, described here:&#x68;&#116;&#x74;&#x70;&#115;&#x3a;&#x2f;&#x2f;&#x6d;&#101;&#100;&#105;&#x75;&#109;&#x2e;&#x63;&#111;&#109;&#x2f;&#64;&#106;&#x6f;&#x6e;&#x61;&#116;&#x68;&#x61;&#x6e;&#99;&#x61;&#114;&#100;&#x6f;&#x73;&#x6f;&#47;&#x75;&#115;&#105;&#x6e;&#x67;&#x2d;&#x66;&#x61;&#x73;&#116;&#108;&#97;&#110;&#x65;&#x2d;&#x6d;&#x61;&#x74;&#99;&#104;&#45;&#119;&#x69;&#116;&#104;&#x2d;&#101;&#x78;&#105;&#x73;&#x74;&#x69;&#x6e;&#x67;&#45;&#99;&#101;&#114;&#116;&#105;&#x66;&#x69;&#x63;&#x61;&#116;&#101;&#x73;&#x2d;&#119;&#105;&#116;&#x68;&#111;&#x75;&#x74;&#45;&#x72;&#x65;&#118;&#x6f;&#107;&#105;&#110;&#x67;&#45;&#x74;&#104;&#x65;&#x6d;&#45;&#97;&#x33;&#x32;&#x35;&#x62;&#x65;&#x36;&#x39;&#100;&#x61;&#99;&#54; Fastlane could just fetch all certificates using Spaceship to get their cert_ids, then extract all identities existing in keychain according to fetched list and then push everything to repo. I suppose it to be run once on a build node/developer mac/etc, and then everyone else could just use fastlane match to install all this certificates in a simple and easy way. 当你需要在多个team之间切换时，注意切换分支。 match also supports storing certificates of multiple teams in one repo, by using separate git branches. If you work in multiple teams, make sure to set the git_branch parameter to a unique value per team. From there, match will automatically create and use the specified branch for you. 环境变量MATCH_PASSWORD是你最开始使用match时创建的git仓库设置的权限密码。 gym这个 action 是进行 archive 和 export 的。 archive 需要配置好对应的Bundle ID，Provisioning Profile（development）， developer 证书。 export需要配置好method，Provisioning Profile（appstore, adhoc, enterprise）， distribution 证书。 如果项目设置了 Automatically manage signing，gym会使用Xcode默认选择的pp文件，不会使用之前match下载的。这对于Bundle ID不会修改来发布企业包的项目来说没什么操心的，但是如果项目Bundle ID以前是com.foo.bar1，现在需要用新的com.foo.bar2来打包，那么archive得到的文件可能Bundle ID为com.foo.bar2，使用的pp文件却是Bundle ID为com.foo.bar1的。之后export（使用的pp文件是新生成的Bundle ID为com.foo.bar2的的）就会报错如下： error: exportArchive: Provisioning profile “match InHouse com.foo.bar2” doesn’t match the entitlements file’s value for the application-identifier entitlement. 就是 archive 和 export 使用的 pp 文件Bundle ID不同。 gym 虽然有 xcargs 这个参数可以配置 archive 时候的Provisioning Profile，可是项目如果有multiple targets (e.g. Today Widget or WatchOS Extension or Notification Extension)，这一个参数怎么给多个target配置pp文件。 于是查看了很多issue之后，发现了automatic_code_signing这个action既可以关闭Automatically manage signing，又可以根据target来设置pp文件。 做好了 archive 和 export 的签名匹配之后，gym打包就能成功了。 12345-allowProvisioningUpdates Allow xcodebuild to communicate with the Apple Developer website. For automatically signed targets, xcodebuild will create and update profiles, app IDs, and certificates. For manually signed targets, xcodebuild will download missing or updated provisioning profiles.Requires a developer account to have been added in Xcode&apos;s Accounts preference pane. 1According to xcodebuild -help, signingStyle defaults to automatic for apps that were automatically signed when archived (which is our case). I assume this is the reason xcodebuild seems to ignore the provisioningProfiles entry.. gym error: gym archive 的过程是根据Xcode中配置的Provisioning Profile（type是development，证书是开发者证书）来 archive 的，export 需要的Provisioning Profile（type是production，证书是发布证书），得注意检查这个 1error: exportArchive: &quot;PushSerives.appex&quot; requires a provisioning profile. 由于项目包含notification service extension，需要 provisioning profile ，所以先使用produce生成App ID，再使用match（其实是sign）生成 provisioning profile ， error: exportArchive: Provisioning profile “match InHouse com.sobeycloud.enterprise.test1” doesn’t support the Push Notifications capability. error: exportArchive: Provisioning profile “match InHouse com.sobeycloud.enterprise.test1” doesn’t include the aps-environment entitlement and doesn’t match the entitlements file’s value for the application-identifier entitlement. error: exportArchive: Provisioning profile “match InHouse com.sobeycloud.enterprise.test1.push” doesn’t match the entitlements file’s value for the application-identifier entitlement. Jenkins+fastlaneError: fastlane: command not found bundle: command not found stackoverflow上有解释，不过在使用全路径时，到后面可能又会碰到error: xcpretty: command not found 根据issue里的描述，可以在”构建”中的shell命令中添加 1PATH=&quot;/usr/local/bin:$PATH&quot; Fatal: could not read Username for ‘https://foo.bar‘: terminal prompts disabled 可参照：issue As you probably know, since you can’t type in a password during your CI builds, match &amp; Git will have trouble using the https authentication method unless your build machine has its keychain set up with the right credentials for your repository. The error message you provided is letting you know that match could not determine the right password to use. It needed to prompt you, but on CI, it is not allowed to prompt because that would cause the build to hang. Our suggestion would be to investigate the Keychains and Provisioning Profiles Plugin mentioned Error: 检查后发现证书和配置文件是下载到打包机器上了的，可是没有打开钥匙串访问权限，所以 CodeSign 失败。 Success: 钉钉上的机器人提醒：]]></content>
  </entry>
  <entry>
    <title><![CDATA[RxSwfit+MVVM简单实践]]></title>
    <url>%2F2017%2F10%2F07%2FRxSwfit%2BMVVM%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[RxSwfit+MVVM简单实践一个简单的活动列表展示页面12345678910111213extension Reactive where Base: LoadingHUD &#123; /// Bindable sink for `startAnimating()`, `stopAnimating()` methods. var isAnimating: Binder&lt;Bool&gt; &#123; return Binder(self.base) &#123; hud, active in if active &#123; hud.startAnimating() &#125; else &#123; hud.stopAnimating() &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556func bindData() &#123; // 加载状态指示器 let activityIndicator = ActivityIndicator() // 将网络请求取得活动列表数据转化为可观察的序列，之后驱动 tableView 使用 // 当观察者对 BehaviorSubject 进行订阅时，它会将源 Observable 中最新的元素发送出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。 let activityResponseDriver = BehaviorSubject(value: ()) .flatMapLatest &#123; Networking .rx.requestObject(ActivityResponse.self, url: URL.notifyList) .trackActivity(activityIndicator) // 追踪加载状态 &#125; .asDriver(onErrorJustReturn: ActivityResponse()) // 驱动HUD activityIndicator.asDriver().drive(hud.rx.isAnimating).disposed(by: disposeBag) // tableView 数据源 let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;String, Activity&gt;&gt;( configureCell: &#123; (_, tv, indexPath, element) in let cell = tv.dequeueReusableCell(withIdentifier: ActivityListCell.classIdentifier, for: indexPath) as! ActivityListCell cell.activity = element return cell &#125;, titleForHeaderInSection: &#123; dataSource, sectionIndex in return dataSource[sectionIndex].model &#125; ) // 活动列表数据通过 map 转化为一个section数据 再驱动tableView activityResponseDriver .map &#123; [SectionModel(model: kActivityNotificationStringLocalized, items: $0.data)] &#125; .drive(tableView.rx.items(dataSource: dataSource)) .disposed(by: disposeBag) // 活动列表数据 驱动统计view的展示 activityResponseDriver .map &#123; $0.informationNum &#125; .drive(onNext: &#123; [unowned self] (informationNum) in self.informationNumView.isHidden = informationNum == 0 self.informationNumView.setTitle("\(informationNum)", for: .normal) &#125;) .disposed(by: disposeBag) tableView.rx.modelSelected(Activity.self) .subscribe(onNext: &#123; [unowned self] (activity) in if #available(iOS 9.0, *) &#123; let vc = SFSafariViewController(url: url) vc.title = kActivityNotificationStringLocalized self.navigationController?.pushViewController(vc, animated: true) &#125; else &#123; let vc = ActivityWebViewController() vc.title = kActivityNotificationStringLocalized vc.url = url self.navigationController?.pushViewController(vc, animated: true) &#125; &#125;) .disposed(by: disposeBag) &#125; 一个订单信息列表页面（DataPageable是一个提供分页功能的序列输出功能类）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475func bindData() &#123; let pageVariable = Variable(1) tableView.mj_header = MJRefreshNormalHeader(refreshingBlock: &#123; pageVariable.value = 1 &#125;) tableView.mj_footer = MJRefreshBackNormalFooter(refreshingBlock: &#123; pageVariable.value += 1 &#125;) let viewModel = OrderInfoListViewModel(pageVariable: pageVariable) // hud viewModel.hudDriver .drive(hud.rx.isAnimating) .disposed(by: disposeBag) // tableView dataSource viewModel.orderInfoListDriver .drive(tableView.rx.items(cellIdentifier: OrderInfoCell.classIdentifier, cellType: OrderInfoCell.self)) &#123; (row, orderInfo, cell) in cell.orderInfo = orderInfo &#125; .disposed(by: disposeBag) // endRefresh viewModel.endHeaderRefreshingDriver .drive(tableView.rx.endHeaderRefreshing) .disposed(by: disposeBag) viewModel.endFooterRefreshingDriver .drive(tableView.rx.endFooterRefreshing) .disposed(by: disposeBag) // some UI viewModel.orderInfoListDriver .skip(1) // skip 跳过第一个元素，emptyView.isHidden .map &#123; $0.count &gt; 0 &#125; .drive(emptyDataView.rx.isHidden) .disposed(by: disposeBag) // tableView Delegate tableView.rx .modelSelected(OrderInfo.self) .subscribe(onNext: &#123; [weak self] orderInfo in let vc = OrderDetailController() vc.tradeNo = orderInfo.tradeNo self?.navigationController?.pushViewController(vc, animated: true) &#125;) .disposed(by: disposeBag) &#125; &#125;class OrderInfoListViewModel &#123; // outputs let hudDriver: Driver&lt;Bool&gt; let orderInfoListDriver: Driver&lt;[OrderInfo]&gt; let endHeaderRefreshingDriver: Driver&lt;Void&gt; let endFooterRefreshingDriver: Driver&lt;Int&gt; init(pageVariable: Variable&lt;Int&gt;) &#123; // 元组，包含网络请求状态序列、数据列表序列，刷新信号 let driversTuple = DataPageable.getDriversTuple(pageVariable: pageVariable, url: URL.consumeRecordQuery, param: ["mobile": UserManager.shared.currentUser!.mobile], type: OrderInfo.self, path: "orderInfo") let taskStatusDriver = driversTuple.taskStatusDriver orderInfoListDriver = driversTuple.dataListDriver endHeaderRefreshingDriver = driversTuple.endHeaderRefreshingDriver endFooterRefreshingDriver = driversTuple.endFooterRefreshingDriver hudDriver = Driver .combineLatest(taskStatusDriver, orderInfoListDriver) &#123; $0.isExecuting &amp;&amp; $1.isEmpty &#125; .distinctUntilChanged() &#125; &#125; 历程学习 RxSwift 是个非常有趣的过程，我最开始是通过 中文文档 + 官方Demo来学习的。看到不是特别能理解的内容时（比如各种创建序列的方式、Subject、Operator），跟着敲一下代码，运行一下，感觉会比较容易记忆和理解。然后把现有的工程一点点MVVM化，遇到问题就回头去看文档和Demo，基本就能把一些简单的业务逻辑搞定了。]]></content>
  </entry>
</search>
