<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用 fastlane 进行 iOS App自动打包]]></title>
    <url>%2F2018%2F06%2F27%2Fuse-fastlane%2F</url>
    <content type="text"><![CDATA[使用 fastlane 进行 iOS App自动打包前言公司 App工厂 项目每天要进行10来次打包分发测试，并且要根据要求按环境、配置进行打包。如果使用手动的方式，不仅效率低，还容易配置出错，对于开发人员来说相当折磨。 Xcodebuild 是一个命令行打包命令，配合脚本使用可以实现简单的打包分发流程，可是不方便更改项目内的一些配置和灵活管理开发者中心的 Certificates 、 Identifiers 、 Provisioning Profiles 。 Fastlane 不仅可以更快的打包，还能够帮助开发者团队管理证书，生成 App ID 、 Provisioning Profile ，生成应用截图，处理代码签名，甚至提交审核。 接下来记录一下我使用 fastlane 时碰到的一些问题。 使用 fastlane首先安装fastlane1xcode-select --install 1[sudo] gem install fastlane -NV 加载.env文件里的环境变量，使用 dotenv —— A Ruby gem to load environment variables from .env.Add this line to the top of your application’s Gemfile: 1gem &apos;dotenv-rails&apos;, groups: [:development, :test] 1$ bundle 1$ gem install dotenv 使用 update_info_plist error: You must specify either a plist path or a scheme 必须设置 plist path 或者 scheme ，然后就可以找到对应的 plist 文件更改CFBundleDisplayName，CFBundleShortVersionString之类的值了。 注意： 使用 update_info_plist 修改不了项目Bundle ID（一般info.plist文件里面CFBundleIdentifier的值是$(PRODUCT_BUNDLE_IDENTIFIER)），因为并不会修改Build Settings里PRODUCT_BUNDLE_IDENTIFIER的值。参考 issue。 produce error: User foo@bar.com doesn’t have enough permission for the following action: user_details_data 出现这个错误是由于我用的开发者账号（企业账号）没有 user_details_data 的权限（应该是跟 appstoreconnect 相关），而参数 skip_itc 没有设为 false 。 还有一个问题是：要想使用 produce 修改已经生成的App ID的 services ，目前produce cannot modify services with a lane，参考这个issue，可以改用命令行修改， 1sh &quot;fastlane produce enable_services --push_notification -a #&#123;bundle_id&#125;&quot; 去文档上查了一下发现有 modify_services 这个 action 可以修改，不过我没有去使用过。 如果项目里有multiple targets (e.g. Today Widget or WatchOS Extension or Notification Extension)，也需要使用produce创建对应的App ID。然而我碰到过另一个问题： An App ID with Identifier ‘com.foo.bar.push’ is not available. Please enter a different string 这个错误应该是由于com.foo.bar.push这个Bundle ID被其它开发者账号用来创建了App ID，解决办法就是： 改用另一个 去那个开发者账号（如果你知道）删除对应的App ID。 可是Xcode开启了自动签名却能生成有效的pp文件，我检查了一下pp文件，发现App ID名称是XC Wildcard，能匹配所有的Bundle ID。接下来我去查了一下资料，发现这是因为Extension的target不使用capabilities，当Xcode开启自动签名，fix issue时，可能会adding a wildcard team provisioning profile， Using a Wildcard App ID is convenient for all apps that do not use capabilities, as they can reuse the same provisioning profile for code signing match error: Could not create another Distribution certificate, reached the maximum number of available Distribution certificates. 当开发者账户中已经有了最大数量的证书时，fastlane match不能创建新的证书，然而也不能使用本地 keychain 中可用的证书并推送到git仓库。 这个 issue 就有人提到希望fastlane match可以使用本地可用的证书。 There will be good to have build-in initializer to export all existing certificates to git repo. The steps are, for example, described here:&#x68;&#x74;&#116;&#x70;&#x73;&#58;&#47;&#47;&#109;&#x65;&#x64;&#x69;&#x75;&#x6d;&#46;&#x63;&#111;&#x6d;&#x2f;&#x40;&#x6a;&#x6f;&#110;&#97;&#x74;&#x68;&#x61;&#x6e;&#99;&#97;&#114;&#100;&#111;&#115;&#x6f;&#x2f;&#117;&#x73;&#105;&#110;&#x67;&#x2d;&#x66;&#x61;&#x73;&#116;&#108;&#x61;&#x6e;&#x65;&#x2d;&#x6d;&#x61;&#116;&#x63;&#104;&#x2d;&#x77;&#x69;&#116;&#104;&#x2d;&#101;&#120;&#x69;&#115;&#116;&#x69;&#x6e;&#x67;&#45;&#x63;&#x65;&#114;&#x74;&#105;&#102;&#x69;&#x63;&#x61;&#116;&#101;&#115;&#45;&#119;&#105;&#116;&#104;&#x6f;&#117;&#x74;&#x2d;&#x72;&#101;&#x76;&#111;&#107;&#105;&#110;&#x67;&#x2d;&#116;&#x68;&#101;&#109;&#x2d;&#x61;&#51;&#x32;&#53;&#x62;&#x65;&#x36;&#x39;&#100;&#x61;&#x63;&#54; Fastlane could just fetch all certificates using Spaceship to get their cert_ids, then extract all identities existing in keychain according to fetched list and then push everything to repo. I suppose it to be run once on a build node/developer mac/etc, and then everyone else could just use fastlane match to install all this certificates in a simple and easy way. 当你需要在多个team之间切换时，注意切换分支。 match also supports storing certificates of multiple teams in one repo, by using separate git branches. If you work in multiple teams, make sure to set the git_branch parameter to a unique value per team. From there, match will automatically create and use the specified branch for you. 环境变量MATCH_PASSWORD是你最开始使用match时创建的git仓库设置的权限密码。 gym这个 action 是进行 archive 和 export 的。 archive 需要配置好对应的Bundle ID，Provisioning Profile（development）， developer 证书。 export需要配置好method，Provisioning Profile（appstore, adhoc, enterprise）， distribution 证书。 如果项目设置了 Automatically manage signing，gym会使用Xcode默认选择的pp文件，不会使用之前match下载的。这对于Bundle ID不会修改来发布企业包的项目来说没什么操心的，但是如果项目Bundle ID以前是com.foo.bar1，现在需要用新的com.foo.bar2来打包，那么archive得到的文件可能Bundle ID为com.foo.bar2，使用的pp文件却是Bundle ID为com.foo.bar1的。之后export（使用的pp文件是新生成的Bundle ID为com.foo.bar2的的）就会报错如下： error: exportArchive: Provisioning profile “match InHouse com.foo.bar2” doesn’t match the entitlements file’s value for the application-identifier entitlement. 就是 archive 和 export 使用的 pp 文件Bundle ID不同。 gym 虽然有 xcargs 这个参数可以配置 archive 时候的Provisioning Profile，可是项目如果有multiple targets (e.g. Today Widget or WatchOS Extension or Notification Extension)，这一个参数怎么给多个target配置pp文件。 于是查看了很多issue之后，发现了automatic_code_signing这个action既可以关闭Automatically manage signing，又可以根据target来设置pp文件。 做好了 archive 和 export 的签名匹配之后，gym打包就能成功了。 12345-allowProvisioningUpdates Allow xcodebuild to communicate with the Apple Developer website. For automatically signed targets, xcodebuild will create and update profiles, app IDs, and certificates. For manually signed targets, xcodebuild will download missing or updated provisioning profiles.Requires a developer account to have been added in Xcode&apos;s Accounts preference pane. 1According to xcodebuild -help, signingStyle defaults to automatic for apps that were automatically signed when archived (which is our case). I assume this is the reason xcodebuild seems to ignore the provisioningProfiles entry.. gym error: gym archive 的过程是根据Xcode中配置的Provisioning Profile（type是development，证书是开发者证书）来 archive 的，export 需要的Provisioning Profile（type是production，证书是发布证书），得注意检查这个 1error: exportArchive: &quot;PushSerives.appex&quot; requires a provisioning profile. 由于项目包含notification service extension，需要 provisioning profile ，所以先使用produce生成App ID，再使用match（其实是sign）生成 provisioning profile ， error: exportArchive: Provisioning profile “match InHouse com.sobeycloud.enterprise.test1” doesn’t support the Push Notifications capability. error: exportArchive: Provisioning profile “match InHouse com.sobeycloud.enterprise.test1” doesn’t include the aps-environment entitlement and doesn’t match the entitlements file’s value for the application-identifier entitlement. error: exportArchive: Provisioning profile “match InHouse com.sobeycloud.enterprise.test1.push” doesn’t match the entitlements file’s value for the application-identifier entitlement. Jenkins+fastlaneError: fastlane: command not found bundle: command not found stackoverflow上有解释，不过在使用全路径时，到后面可能又会碰到error: xcpretty: command not found 根据issue里的描述，可以在”构建”中的shell命令中添加 1PATH=&quot;/usr/local/bin:$PATH&quot; Fatal: could not read Username for ‘https://foo.bar‘: terminal prompts disabled 可参照：issue As you probably know, since you can’t type in a password during your CI builds, match &amp; Git will have trouble using the https authentication method unless your build machine has its keychain set up with the right credentials for your repository. The error message you provided is letting you know that match could not determine the right password to use. It needed to prompt you, but on CI, it is not allowed to prompt because that would cause the build to hang. Our suggestion would be to investigate the Keychains and Provisioning Profiles Plugin mentioned Error: 检查后发现证书和配置文件是下载到打包机器上了的，可是没有打开钥匙串访问权限，所以 CodeSign 失败。 Success: 钉钉上的机器人提醒： 总结由于项目总共有大量租户App，工作时间随时都可能会有发布企业包测试要求，而每个租户App的环境与配置都不一样，我们开发人员一个一个手动修改环境和配置文件将耗费很大的精力与时间，且容易出错。于是我将所需配置的变量全部放在 .env 文件中，包括要上架 App Store 的开发者账号，将证书同步到Git中管理，保证能够在企业账号和不同公司账号之间自动切换。最后成功将打包+分发时间从 30分钟以上 降低到 3分钟以内 ，且大大降低了手动修改环境和配置造成的出错概率。 以下是 Fastfile 中的核心代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140xcodeproj_path = "./MyApp.xcodeproj"username = ENV["FASTLANE_USER"]team_id = ENV["TEAM_ID"]scheme = ENV["SCHEME"]bundle_id = ENV["BUNDLE_ID"]app_name = ENV["APP_NAME"]version_number = ENV["VERSION"]build_number = ENV["BUILD"]export_method = ENV["EXPORT_METHOD"]pgy_api_key = ENV["pgy_api_key"]pgy_user_key = ENV["pgy_user_key"]sentry_auth_token = ENV["sentry_auth_token"]sentry_org_slug = ENV["sentry_org_slug"]sentry_project_slug = ENV["sentry_project_slug"]url_schemes_wechat = [ENV["app_key_wechat"]]url_schemes_qq = ["tencent" + ENV["app_key_qq"]]url_schemes_sina = ["wb" + ENV["app_key_sina"]]url_schemes_eg = [ENV["app_key_eg"]]url_schemes_yz = [ENV["app_key_yz"]]url_schemes_appfactory = [bundle_id.delete(".")]platform :ios do before_all do |lane, options| setup_jenkins end desc "Push a new beta build to pgy" lane :build do |options| on_update_info_plist on_match on_gym upload_symbols_to_sentry( auth_token: sentry_auth_token, org_slug: sentry_org_slug, project_slug: sentry_project_slug, ) if export_method == "appstore" pgyer( api_key: pgy_api_key, user_key: pgy_user_key, ) unless export_method == "appstore" end lane :on_match do produce( username: username, app_identifier: bundle_id, app_name: app_name, skip_itc: true, enable_services: &#123; push_notification: "on", &#125; ) match( git_branch: username, username: username, type: "development", app_identifier: [bundle_id], ) match( git_branch: username, username: username, type: export_method, app_identifier: [bundle_id], ) end lane :on_gym do profile_name = ENV["sigh_#&#123;bundle_id&#125;_development_profile-name"] UI.important "profile_name = '#&#123;profile_name&#125;'" automatic_code_signing( path: xcodeproj_path, targets: [scheme], use_automatic_signing: false, profile_name: profile_name, team_id: team_id, bundle_identifier: bundle_id, ) gym( scheme: scheme, # clean: true, silent: true, export_options: &#123; method: export_method, &#125; ) end lane :on_update_info_plist do update_info_plist( xcodeproj: xcodeproj_path, scheme: scheme, block: proc do |plist| plist["CFBundleDisplayName"] = app_name plist["CFBundleName"] = app_name plist["CFBundleShortVersionString"] = version_number plist["CFBundleVersion"] = build_number urlScheme = plist["CFBundleURLTypes"].find&#123; |scheme| scheme["CFBundleURLName"] == "appfactory" &#125; if urlScheme urlScheme["CFBundleURLSchemes"] = url_schemes_appfactory else plist["CFBundleURLTypes"] = plist["CFBundleURLTypes"] + [&#123;"CFBundleTypeRole" =&gt; "Editor", "CFBundleURLName" =&gt; "appfactory", "CFBundleURLSchemes" =&gt; url_schemes_appfactory&#125;] end urlScheme = plist["CFBundleURLTypes"].find&#123; |scheme| scheme["CFBundleURLName"] == "weixin" &#125; urlScheme["CFBundleURLSchemes"] = url_schemes_wechat if urlScheme urlScheme = plist["CFBundleURLTypes"].find&#123; |scheme| scheme["CFBundleURLName"] == "tencentLogin" &#125; urlScheme["CFBundleURLSchemes"] = url_schemes_qq if urlScheme urlScheme = plist["CFBundleURLTypes"].find&#123; |scheme| scheme["CFBundleURLName"] == "wb" &#125; urlScheme["CFBundleURLSchemes"] = url_schemes_sina if urlScheme urlScheme = plist["CFBundleURLTypes"].find&#123; |scheme| scheme["CFBundleURLName"] == "EGMonitor" &#125; urlScheme["CFBundleURLSchemes"] = url_schemes_eg if urlScheme urlScheme = plist["CFBundleURLTypes"].find&#123; |scheme| scheme["CFBundleURLName"] == "YZYUN" &#125; urlScheme["CFBundleURLSchemes"] = url_schemes_yz if urlScheme end ) endend]]></content>
  </entry>
  <entry>
    <title><![CDATA[在项目中引入 ijkplayer]]></title>
    <url>%2F2018%2F06%2F11%2Fuse-ijkplayer%2F</url>
    <content type="text"><![CDATA[ijkplayer前言ijkplayer 是 Bilibili 开源的一款提供给iOS/Android平台的视频播放器，基于 FFmpeg，支持 MediaCodec，VideoToolbox。官方不直接提供 framework框架包，而是给出相关的配置文件，这样我们可以根据需要来选择配置，编译并打包 获取、编译、打包获取ijkplayer、openssl（支持HTTPS，可选）、ffmpeg123456789101112# clone ijkplayer 到本地git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-ioscd ijkplayer-ios# 基于远程 branch/tag "k0.8.8"，创建一个叫"latest"的分支git checkout -B latest k0.8.8# 拉取openssl 可去掉armv7(32位的真机)sh init-ios-openssl.sh# 拉取ffmpeg 可去掉armv7sh init-ios.sh In iOS devices, armv7 means iPhone 4 or iPad 1 and so on, armv7s meas iPhone 5 and so on, all it’s 32 bit device. And Apple has required all apps should run on 64 bit. 编译有三个脚本来配置编解码器的功能支持，可根据需要选择或者更改 module-default.sh 更多的编解码器/格式 module-lite-hevc.sh 较少的编解码器/格式（包括hevc） module-lite.sh 较少的编解码器/格式（默认） 1234cd configrm module.sh# 建立软连接：可选&apos;module-default.sh&apos;，&apos;module-lite-hevc.sh&apos;，&apos;module-lite.sh&apos;ln -s module-lite.sh module.sh 目前ijkplayer默认不支持HTTPS，如果需要，得先启用并编译openssl 12# 要启用 openssl 组件，得在module.sh脚本文件中添加一行配置echo &apos;export COMMON_FF_CFG_FLAGS=&quot;$COMMON_FF_CFG_FLAGS --enable-openssl&quot;&apos; &gt;&gt; module.sh 确认已启用openssl 然后开始编译，编译ffmpeg前，请查看issue #4150。 123456./compile-openssl.sh clean./compile-ffmpeg.sh clean# 编译openssl 可去掉armv7./compile-openssl.sh all# 编译ffmpeg 得去掉armv7./compile-ffmpeg.sh all 打包framework用命令或手动打开 ios 目录下的 IJKMediaPlayer 1open IJKMediaPlayer/IJKMediaPlayer.xcodeproj 这里使用Target IJKMediaFramework 。如果使用 https，就需要手动给 IJKMediaFramework 添加 libcrypto.a 和 libssl.a 文件，默认不会添加。这两个依赖库的目录为: ijkplayer-ios/ios/build/universal/lib，是通过之前 ./compile-openssl.sh all 生成的 参考 这个博客 在 Edit Scheme 中配置 Build Configuration 为 Release 模式 选择真机 进行 build 编译，注释掉报错的地方 选择模拟器 进行 build 编译 合并 framework 先 cd 到 Products 目录下，然后执行 1lipo -create Release-iphoneos/IJKMediaFramework.framework/IJKMediaFramework Release-iphonesimulator/IJKMediaFramework.framework/IJKMediaFramework -output IJKMediaFramework 替换 这个 IJKMediaFramework.framework 就是打包好的 集成 添加下列依赖到工程 libc++.tbd libz.tbd libbz2.tbd AudioToolbox.framework UIKit.framework CoreGraphics.framework AVFoundation.framework CoreMedia.framework CoreVideo.framework MediaPlayer.framework MobileCoreServices.framework OpenGLES.framework QuartzCore.framework VideoToolbox.framework 参考文章ijkplayer 的编译、打包 framework 和 https 支持 iOS 中的 armv7,armv7s,arm64,i386,x86_64 都是什么]]></content>
  </entry>
  <entry>
    <title><![CDATA[RxSwfit+MVVM简单实践]]></title>
    <url>%2F2017%2F10%2F07%2FRxSwfit%2BMVVM%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[RxSwfit+MVVM简单实践一个简单的活动列表展示页面12345678910111213extension Reactive where Base: LoadingHUD &#123; /// Bindable sink for `startAnimating()`, `stopAnimating()` methods. var isAnimating: Binder&lt;Bool&gt; &#123; return Binder(self.base) &#123; hud, active in if active &#123; hud.startAnimating() &#125; else &#123; hud.stopAnimating() &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556func bindData() &#123; // 加载状态指示器 let activityIndicator = ActivityIndicator() // 将网络请求取得活动列表数据转化为可观察的序列，之后驱动 tableView 使用 // 当观察者对 BehaviorSubject 进行订阅时，它会将源 Observable 中最新的元素发送出来（如果不存在最新的元素，就发出默认元素）。然后将随后产生的元素发送出来。 let activityResponseDriver = BehaviorSubject(value: ()) .flatMapLatest &#123; Networking .rx.requestObject(ActivityResponse.self, url: URL.notifyList) .trackActivity(activityIndicator) // 追踪加载状态 &#125; .asDriver(onErrorJustReturn: ActivityResponse()) // 驱动HUD activityIndicator.asDriver().drive(hud.rx.isAnimating).disposed(by: disposeBag) // tableView 数据源 let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;String, Activity&gt;&gt;( configureCell: &#123; (_, tv, indexPath, element) in let cell = tv.dequeueReusableCell(withIdentifier: ActivityListCell.classIdentifier, for: indexPath) as! ActivityListCell cell.activity = element return cell &#125;, titleForHeaderInSection: &#123; dataSource, sectionIndex in return dataSource[sectionIndex].model &#125; ) // 活动列表数据通过 map 转化为一个section数据 再驱动tableView activityResponseDriver .map &#123; [SectionModel(model: kActivityNotificationStringLocalized, items: $0.data)] &#125; .drive(tableView.rx.items(dataSource: dataSource)) .disposed(by: disposeBag) // 活动列表数据 驱动统计view的展示 activityResponseDriver .map &#123; $0.informationNum &#125; .drive(onNext: &#123; [unowned self] (informationNum) in self.informationNumView.isHidden = informationNum == 0 self.informationNumView.setTitle("\(informationNum)", for: .normal) &#125;) .disposed(by: disposeBag) tableView.rx.modelSelected(Activity.self) .subscribe(onNext: &#123; [unowned self] (activity) in if #available(iOS 9.0, *) &#123; let vc = SFSafariViewController(url: url) vc.title = kActivityNotificationStringLocalized self.navigationController?.pushViewController(vc, animated: true) &#125; else &#123; let vc = ActivityWebViewController() vc.title = kActivityNotificationStringLocalized vc.url = url self.navigationController?.pushViewController(vc, animated: true) &#125; &#125;) .disposed(by: disposeBag) &#125; 一个订单信息列表页面（DataPageable是一个提供分页功能的序列输出功能类）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475func bindData() &#123; let pageVariable = Variable(1) tableView.mj_header = MJRefreshNormalHeader(refreshingBlock: &#123; pageVariable.value = 1 &#125;) tableView.mj_footer = MJRefreshBackNormalFooter(refreshingBlock: &#123; pageVariable.value += 1 &#125;) let viewModel = OrderInfoListViewModel(pageVariable: pageVariable) // hud viewModel.hudDriver .drive(hud.rx.isAnimating) .disposed(by: disposeBag) // tableView dataSource viewModel.orderInfoListDriver .drive(tableView.rx.items(cellIdentifier: OrderInfoCell.classIdentifier, cellType: OrderInfoCell.self)) &#123; (row, orderInfo, cell) in cell.orderInfo = orderInfo &#125; .disposed(by: disposeBag) // endRefresh viewModel.endHeaderRefreshingDriver .drive(tableView.rx.endHeaderRefreshing) .disposed(by: disposeBag) viewModel.endFooterRefreshingDriver .drive(tableView.rx.endFooterRefreshing) .disposed(by: disposeBag) // some UI viewModel.orderInfoListDriver .skip(1) // skip 跳过第一个元素，emptyView.isHidden .map &#123; $0.count &gt; 0 &#125; .drive(emptyDataView.rx.isHidden) .disposed(by: disposeBag) // tableView Delegate tableView.rx .modelSelected(OrderInfo.self) .subscribe(onNext: &#123; [weak self] orderInfo in let vc = OrderDetailController() vc.tradeNo = orderInfo.tradeNo self?.navigationController?.pushViewController(vc, animated: true) &#125;) .disposed(by: disposeBag) &#125; &#125;class OrderInfoListViewModel &#123; // outputs let hudDriver: Driver&lt;Bool&gt; let orderInfoListDriver: Driver&lt;[OrderInfo]&gt; let endHeaderRefreshingDriver: Driver&lt;Void&gt; let endFooterRefreshingDriver: Driver&lt;Int&gt; init(pageVariable: Variable&lt;Int&gt;) &#123; // 元组，包含网络请求状态序列、数据列表序列，刷新信号 let driversTuple = DataPageable.getDriversTuple(pageVariable: pageVariable, url: URL.consumeRecordQuery, param: ["mobile": UserManager.shared.currentUser!.mobile], type: OrderInfo.self, path: "orderInfo") let taskStatusDriver = driversTuple.taskStatusDriver orderInfoListDriver = driversTuple.dataListDriver endHeaderRefreshingDriver = driversTuple.endHeaderRefreshingDriver endFooterRefreshingDriver = driversTuple.endFooterRefreshingDriver hudDriver = Driver .combineLatest(taskStatusDriver, orderInfoListDriver) &#123; $0.isExecuting &amp;&amp; $1.isEmpty &#125; .distinctUntilChanged() &#125; &#125; 历程我最开始是通过 官方电子书 + Demo来学习的，也看过 中文文档 。看到不是特别能理解的内容时（比如各种创建序列的方式、Subject、Operator），跟着敲一下代码，运行一下，感觉会比较容易记忆和理解，也会惊叹代码还可以这样简洁，感觉学习 RxSwift 是个非常有趣的过程。然后把现有的工程一点点MVVM化，遇到问题就回头去看文档和Demo，加深印象和理解，基本就能处理一些简单的业务逻辑了。]]></content>
  </entry>
</search>
